<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>segger.validation.utils &#8212; Segger 0.1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=12dfc556" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=fd3f3429" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-design.min.css?v=95c83b7e" />
    <script src="../../../_static/documentation_options.js?v=a1637f0b"></script>
    <script src="../../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../../_static/copybutton.js?v=4ea706d9"></script>
    <script src="../../../_static/scripts/sphinx-book-theme.js"></script>
    <script src="../../../_static/design-tabs.js?v=f930bc37"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for segger.validation.utils</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">anndata</span> <span class="k">as</span> <span class="nn">ad</span>
<span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">ConvexHull</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>
<span class="kn">import</span> <span class="nn">scanpy</span> <span class="k">as</span> <span class="nn">sc</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">combinations</span>
<span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="kn">import</span> <span class="n">pdist</span><span class="p">,</span> <span class="n">squareform</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">entropy</span>
<span class="kn">from</span> <span class="nn">matplotlib.backends.backend_pdf</span> <span class="kn">import</span> <span class="n">PdfPages</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">dask</span>
<span class="n">dask</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">({</span><span class="s1">&#39;dataframe.query-planning&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">})</span>
<span class="kn">import</span> <span class="nn">squidpy</span> <span class="k">as</span> <span class="nn">sq</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">calinski_harabasz_score</span><span class="p">,</span> <span class="n">silhouette_score</span><span class="p">,</span> <span class="n">f1_score</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>





<div class="viewcode-block" id="find_markers">
<a class="viewcode-back" href="../../../api/validation/utils/index.html#segger.validation.utils.find_markers">[docs]</a>
<span class="k">def</span> <span class="nf">find_markers</span><span class="p">(</span>
    <span class="n">adata</span><span class="p">:</span> <span class="n">ad</span><span class="o">.</span><span class="n">AnnData</span><span class="p">,</span> 
    <span class="n">cell_type_column</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> 
    <span class="n">pos_percentile</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> 
    <span class="n">neg_percentile</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> 
    <span class="n">percentage</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">50</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Identify positive and negative markers for each cell type based on gene expression and filter by expression percentage.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - adata: AnnData</span>
<span class="sd">        Annotated data object containing gene expression data.</span>
<span class="sd">    - cell_type_column: str</span>
<span class="sd">        Column name in `adata.obs` that specifies cell types.</span>
<span class="sd">    - pos_percentile: float, default=5</span>
<span class="sd">        Percentile threshold to determine top x% expressed genes.</span>
<span class="sd">    - neg_percentile: float, default=10</span>
<span class="sd">        Percentile threshold to determine top x% lowly expressed genes.</span>
<span class="sd">    - percentage: float, default=50</span>
<span class="sd">        Minimum percentage of cells expressing the marker within a cell type for it to be considered.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - markers: dict</span>
<span class="sd">        Dictionary where keys are cell types and values are dictionaries containing:</span>
<span class="sd">            &#39;positive&#39;: list of top x% highly expressed genes</span>
<span class="sd">            &#39;negative&#39;: list of top x% lowly expressed genes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">markers</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">sc</span><span class="o">.</span><span class="n">tl</span><span class="o">.</span><span class="n">rank_genes_groups</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">groupby</span><span class="o">=</span><span class="n">cell_type_column</span><span class="p">)</span>
    <span class="n">genes</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">var_names</span>
    <span class="k">for</span> <span class="n">cell_type</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">cell_type_column</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>
        <span class="n">subset</span> <span class="o">=</span> <span class="n">adata</span><span class="p">[</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">cell_type_column</span><span class="p">]</span> <span class="o">==</span> <span class="n">cell_type</span><span class="p">]</span>
        <span class="n">mean_expression</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">subset</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">cutoff_high</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">mean_expression</span><span class="p">,</span> <span class="mi">100</span> <span class="o">-</span> <span class="n">pos_percentile</span><span class="p">)</span>
        <span class="n">cutoff_low</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">mean_expression</span><span class="p">,</span> <span class="n">neg_percentile</span><span class="p">)</span>
        <span class="n">pos_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mean_expression</span> <span class="o">&gt;=</span> <span class="n">cutoff_high</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">neg_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mean_expression</span> <span class="o">&lt;=</span> <span class="n">cutoff_low</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">expr_frac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">((</span><span class="n">subset</span><span class="o">.</span><span class="n">X</span><span class="p">[:,</span> <span class="n">pos_indices</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">valid_pos_indices</span> <span class="o">=</span> <span class="n">pos_indices</span><span class="p">[</span><span class="n">expr_frac</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">percentage</span> <span class="o">/</span> <span class="mi">100</span><span class="p">)]</span>
        <span class="n">positive_markers</span> <span class="o">=</span> <span class="n">genes</span><span class="p">[</span><span class="n">valid_pos_indices</span><span class="p">]</span>
        <span class="n">negative_markers</span> <span class="o">=</span> <span class="n">genes</span><span class="p">[</span><span class="n">neg_indices</span><span class="p">]</span>
        <span class="n">markers</span><span class="p">[</span><span class="n">cell_type</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;positive&#39;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">positive_markers</span><span class="p">),</span>
            <span class="s1">&#39;negative&#39;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">negative_markers</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="k">return</span> <span class="n">markers</span></div>



<div class="viewcode-block" id="find_mutually_exclusive_genes">
<a class="viewcode-back" href="../../../api/validation/utils/index.html#segger.validation.utils.find_mutually_exclusive_genes">[docs]</a>
<span class="k">def</span> <span class="nf">find_mutually_exclusive_genes</span><span class="p">(</span>
    <span class="n">adata</span><span class="p">:</span> <span class="n">ad</span><span class="o">.</span><span class="n">AnnData</span><span class="p">,</span> 
    <span class="n">markers</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]],</span> 
    <span class="n">cell_type_column</span><span class="p">:</span> <span class="nb">str</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Identify mutually exclusive genes based on expression criteria.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - adata: AnnData</span>
<span class="sd">        Annotated data object containing gene expression data.</span>
<span class="sd">    - markers: dict</span>
<span class="sd">        Dictionary where keys are cell types and values are dictionaries containing:</span>
<span class="sd">            &#39;positive&#39;: list of top x% highly expressed genes</span>
<span class="sd">            &#39;negative&#39;: list of top x% lowly expressed genes.</span>
<span class="sd">    - cell_type_column: str</span>
<span class="sd">        Column name in `adata.obs` that specifies cell types.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - exclusive_pairs: list</span>
<span class="sd">        List of mutually exclusive gene pairs.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">exclusive_genes</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">all_exclusive</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">gene_expression</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">to_df</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">cell_type</span><span class="p">,</span> <span class="n">marker_sets</span> <span class="ow">in</span> <span class="n">markers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">positive_markers</span> <span class="o">=</span> <span class="n">marker_sets</span><span class="p">[</span><span class="s1">&#39;positive&#39;</span><span class="p">]</span>
        <span class="n">exclusive_genes</span><span class="p">[</span><span class="n">cell_type</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">gene</span> <span class="ow">in</span> <span class="n">positive_markers</span><span class="p">:</span>
            <span class="n">gene_expr</span> <span class="o">=</span> <span class="n">adata</span><span class="p">[:,</span> <span class="n">gene</span><span class="p">]</span><span class="o">.</span><span class="n">X</span>
            <span class="n">cell_type_mask</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">cell_type_column</span><span class="p">]</span> <span class="o">==</span> <span class="n">cell_type</span>
            <span class="n">non_cell_type_mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">cell_type_mask</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">gene_expr</span><span class="p">[</span><span class="n">cell_type_mask</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mf">0.2</span> <span class="ow">and</span> <span class="p">(</span><span class="n">gene_expr</span><span class="p">[</span><span class="n">non_cell_type_mask</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.05</span><span class="p">:</span>
                <span class="n">exclusive_genes</span><span class="p">[</span><span class="n">cell_type</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gene</span><span class="p">)</span>
                <span class="n">all_exclusive</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gene</span><span class="p">)</span>
    <span class="n">unique_genes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">({</span><span class="n">gene</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">exclusive_genes</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">for</span> <span class="n">gene</span> <span class="ow">in</span> <span class="n">exclusive_genes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">gene</span> <span class="ow">in</span> <span class="n">all_exclusive</span><span class="p">})</span>
    <span class="n">filtered_exclusive_genes</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="p">[</span><span class="n">gene</span> <span class="k">for</span> <span class="n">gene</span> <span class="ow">in</span> <span class="n">exclusive_genes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">gene</span> <span class="ow">in</span> <span class="n">unique_genes</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">exclusive_genes</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>
    <span class="n">mutually_exclusive_gene_pairs</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="n">gene1</span><span class="p">,</span> <span class="n">gene2</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key1</span><span class="p">,</span> <span class="n">key2</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">(</span><span class="n">filtered_exclusive_genes</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">gene1</span> <span class="ow">in</span> <span class="n">filtered_exclusive_genes</span><span class="p">[</span><span class="n">key1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">gene2</span> <span class="ow">in</span> <span class="n">filtered_exclusive_genes</span><span class="p">[</span><span class="n">key2</span><span class="p">]</span>
    <span class="p">]</span>
    <span class="k">return</span> <span class="n">mutually_exclusive_gene_pairs</span></div>



<div class="viewcode-block" id="compute_MECR">
<a class="viewcode-back" href="../../../api/validation/utils/index.html#segger.validation.utils.compute_MECR">[docs]</a>
<span class="k">def</span> <span class="nf">compute_MECR</span><span class="p">(</span>
    <span class="n">adata</span><span class="p">:</span> <span class="n">ad</span><span class="o">.</span><span class="n">AnnData</span><span class="p">,</span> 
    <span class="n">gene_pairs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the Mutually Exclusive Co-expression Rate (MECR) for each gene pair in an AnnData object.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - adata: AnnData</span>
<span class="sd">        Annotated data object containing gene expression data.</span>
<span class="sd">    - gene_pairs: List[Tuple[str, str]]</span>
<span class="sd">        List of tuples representing gene pairs to evaluate.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - mecr_dict: Dict[Tuple[str, str], float]</span>
<span class="sd">        Dictionary where keys are gene pairs (tuples) and values are MECR values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mecr_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">gene_expression</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">to_df</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">gene1</span><span class="p">,</span> <span class="n">gene2</span> <span class="ow">in</span> <span class="n">gene_pairs</span><span class="p">:</span>
        <span class="n">expr_gene1</span> <span class="o">=</span> <span class="n">gene_expression</span><span class="p">[</span><span class="n">gene1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">expr_gene2</span> <span class="o">=</span> <span class="n">gene_expression</span><span class="p">[</span><span class="n">gene2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">both_expressed</span> <span class="o">=</span> <span class="p">(</span><span class="n">expr_gene1</span> <span class="o">&amp;</span> <span class="n">expr_gene2</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">at_least_one_expressed</span> <span class="o">=</span> <span class="p">(</span><span class="n">expr_gene1</span> <span class="o">|</span> <span class="n">expr_gene2</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">mecr</span> <span class="o">=</span> <span class="n">both_expressed</span> <span class="o">/</span> <span class="n">at_least_one_expressed</span> <span class="k">if</span> <span class="n">at_least_one_expressed</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="n">mecr_dict</span><span class="p">[(</span><span class="n">gene1</span><span class="p">,</span> <span class="n">gene2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">mecr</span>
    <span class="k">return</span> <span class="n">mecr_dict</span></div>



<div class="viewcode-block" id="compute_quantized_mecr_area">
<a class="viewcode-back" href="../../../api/validation/utils/index.html#segger.validation.utils.compute_quantized_mecr_area">[docs]</a>
<span class="k">def</span> <span class="nf">compute_quantized_mecr_area</span><span class="p">(</span>
    <span class="n">adata</span><span class="p">:</span> <span class="n">sc</span><span class="o">.</span><span class="n">AnnData</span><span class="p">,</span> 
    <span class="n">gene_pairs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]],</span> 
    <span class="n">quantiles</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the average MECR, variance of MECR, and average cell area for quantiles of cell areas.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - adata: AnnData</span>
<span class="sd">        Annotated data object containing gene expression data.</span>
<span class="sd">    - gene_pairs: List[Tuple[str, str]]</span>
<span class="sd">        List of tuples representing gene pairs to evaluate.</span>
<span class="sd">    - quantiles: int, default=10</span>
<span class="sd">        Number of quantiles to divide the data into.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - quantized_data: pd.DataFrame</span>
<span class="sd">        DataFrame containing quantile information, average MECR, variance of MECR, average area, and number of cells.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s1">&#39;quantile&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">qcut</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s1">&#39;cell_area&#39;</span><span class="p">],</span> <span class="n">quantiles</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">quantized_data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">quantile</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">quantiles</span><span class="p">):</span>
        <span class="n">cells_in_quantile</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s1">&#39;quantile&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">quantile</span>
        <span class="n">mecr</span> <span class="o">=</span> <span class="n">compute_MECR</span><span class="p">(</span><span class="n">adata</span><span class="p">[</span><span class="n">cells_in_quantile</span><span class="p">,</span> <span class="p">:],</span> <span class="n">gene_pairs</span><span class="p">)</span>
        <span class="n">average_mecr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">mecr</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>
        <span class="n">variance_mecr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">mecr</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>
        <span class="n">average_area</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">cells_in_quantile</span><span class="p">,</span> <span class="s1">&#39;cell_area&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">quantized_data</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
            <span class="s1">&#39;quantile&#39;</span><span class="p">:</span> <span class="n">quantile</span> <span class="o">/</span> <span class="n">quantiles</span><span class="p">,</span>
            <span class="s1">&#39;average_mecr&#39;</span><span class="p">:</span> <span class="n">average_mecr</span><span class="p">,</span>
            <span class="s1">&#39;variance_mecr&#39;</span><span class="p">:</span> <span class="n">variance_mecr</span><span class="p">,</span>
            <span class="s1">&#39;average_area&#39;</span><span class="p">:</span> <span class="n">average_area</span><span class="p">,</span>
            <span class="s1">&#39;num_cells&#39;</span><span class="p">:</span> <span class="n">cells_in_quantile</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="p">})</span>
    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">quantized_data</span><span class="p">)</span></div>



<div class="viewcode-block" id="compute_quantized_mecr_counts">
<a class="viewcode-back" href="../../../api/validation/utils/index.html#segger.validation.utils.compute_quantized_mecr_counts">[docs]</a>
<span class="k">def</span> <span class="nf">compute_quantized_mecr_counts</span><span class="p">(</span>
    <span class="n">adata</span><span class="p">:</span> <span class="n">sc</span><span class="o">.</span><span class="n">AnnData</span><span class="p">,</span> 
    <span class="n">gene_pairs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]],</span> 
    <span class="n">quantiles</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the average MECR, variance of MECR, and average transcript counts for quantiles of transcript counts.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - adata: AnnData</span>
<span class="sd">        Annotated data object containing gene expression data.</span>
<span class="sd">    - gene_pairs: List[Tuple[str, str]]</span>
<span class="sd">        List of tuples representing gene pairs to evaluate.</span>
<span class="sd">    - quantiles: int, default=10</span>
<span class="sd">        Number of quantiles to divide the data into.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - quantized_data: pd.DataFrame</span>
<span class="sd">        DataFrame containing quantile information, average MECR, variance of MECR, average counts, and number of cells.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s1">&#39;quantile&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">qcut</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s1">&#39;transcripts&#39;</span><span class="p">],</span> <span class="n">quantiles</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">quantized_data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">quantile</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">quantiles</span><span class="p">):</span>
        <span class="n">cells_in_quantile</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s1">&#39;quantile&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">quantile</span>
        <span class="n">mecr</span> <span class="o">=</span> <span class="n">compute_MECR</span><span class="p">(</span><span class="n">adata</span><span class="p">[</span><span class="n">cells_in_quantile</span><span class="p">,</span> <span class="p">:],</span> <span class="n">gene_pairs</span><span class="p">)</span>
        <span class="n">average_mecr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">mecr</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>
        <span class="n">variance_mecr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">mecr</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>
        <span class="n">average_counts</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">cells_in_quantile</span><span class="p">,</span> <span class="s1">&#39;transcripts&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">quantized_data</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
            <span class="s1">&#39;quantile&#39;</span><span class="p">:</span> <span class="n">quantile</span> <span class="o">/</span> <span class="n">quantiles</span><span class="p">,</span>
            <span class="s1">&#39;average_mecr&#39;</span><span class="p">:</span> <span class="n">average_mecr</span><span class="p">,</span>
            <span class="s1">&#39;variance_mecr&#39;</span><span class="p">:</span> <span class="n">variance_mecr</span><span class="p">,</span>
            <span class="s1">&#39;average_counts&#39;</span><span class="p">:</span> <span class="n">average_counts</span><span class="p">,</span>
            <span class="s1">&#39;num_cells&#39;</span><span class="p">:</span> <span class="n">cells_in_quantile</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="p">})</span>
    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">quantized_data</span><span class="p">)</span></div>



<div class="viewcode-block" id="annotate_query_with_reference">
<a class="viewcode-back" href="../../../api/validation/utils/index.html#segger.validation.utils.annotate_query_with_reference">[docs]</a>
<span class="k">def</span> <span class="nf">annotate_query_with_reference</span><span class="p">(</span>
    <span class="n">reference_adata</span><span class="p">:</span> <span class="n">ad</span><span class="o">.</span><span class="n">AnnData</span><span class="p">,</span> 
    <span class="n">query_adata</span><span class="p">:</span> <span class="n">ad</span><span class="o">.</span><span class="n">AnnData</span><span class="p">,</span> 
    <span class="n">transfer_column</span><span class="p">:</span> <span class="nb">str</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ad</span><span class="o">.</span><span class="n">AnnData</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Annotate query AnnData object using a scRNA-seq reference atlas.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - reference_adata: ad.AnnData</span>
<span class="sd">        Reference AnnData object containing the scRNA-seq atlas data.</span>
<span class="sd">    - query_adata: ad.AnnData</span>
<span class="sd">        Query AnnData object containing the data to be annotated.</span>
<span class="sd">    - transfer_column: str</span>
<span class="sd">        The name of the column in the reference atlas&#39;s `obs` to transfer to the query dataset.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - query_adata: ad.AnnData</span>
<span class="sd">        Annotated query AnnData object with transferred labels and UMAP coordinates from the reference.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">common_genes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">reference_adata</span><span class="o">.</span><span class="n">var_names</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">query_adata</span><span class="o">.</span><span class="n">var_names</span><span class="p">))</span>
    <span class="n">reference_adata</span> <span class="o">=</span> <span class="n">reference_adata</span><span class="p">[:,</span> <span class="n">common_genes</span><span class="p">]</span>
    <span class="n">query_adata</span> <span class="o">=</span> <span class="n">query_adata</span><span class="p">[:,</span> <span class="n">common_genes</span><span class="p">]</span>
    <span class="n">query_adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="s1">&#39;raw&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">query_adata</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">X</span> <span class="k">if</span> <span class="n">query_adata</span><span class="o">.</span><span class="n">raw</span> <span class="k">else</span> <span class="n">query_adata</span><span class="o">.</span><span class="n">X</span>
    <span class="n">query_adata</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;raw_counts&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">query_adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="s1">&#39;raw&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">sc</span><span class="o">.</span><span class="n">pp</span><span class="o">.</span><span class="n">normalize_total</span><span class="p">(</span><span class="n">query_adata</span><span class="p">,</span> <span class="n">target_sum</span><span class="o">=</span><span class="mf">1e4</span><span class="p">)</span>
    <span class="n">sc</span><span class="o">.</span><span class="n">pp</span><span class="o">.</span><span class="n">log1p</span><span class="p">(</span><span class="n">query_adata</span><span class="p">)</span>
    <span class="n">sc</span><span class="o">.</span><span class="n">pp</span><span class="o">.</span><span class="n">pca</span><span class="p">(</span><span class="n">reference_adata</span><span class="p">)</span>
    <span class="n">sc</span><span class="o">.</span><span class="n">pp</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">reference_adata</span><span class="p">)</span>
    <span class="n">sc</span><span class="o">.</span><span class="n">tl</span><span class="o">.</span><span class="n">umap</span><span class="p">(</span><span class="n">reference_adata</span><span class="p">)</span>
    <span class="n">sc</span><span class="o">.</span><span class="n">tl</span><span class="o">.</span><span class="n">ingest</span><span class="p">(</span><span class="n">query_adata</span><span class="p">,</span> <span class="n">reference_adata</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="n">transfer_column</span><span class="p">)</span>
    <span class="n">query_adata</span><span class="o">.</span><span class="n">obsm</span><span class="p">[</span><span class="s1">&#39;X_umap&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">query_adata</span><span class="o">.</span><span class="n">obsm</span><span class="p">[</span><span class="s1">&#39;X_umap&#39;</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">query_adata</span></div>



<div class="viewcode-block" id="calculate_contamination">
<a class="viewcode-back" href="../../../api/validation/utils/index.html#segger.validation.utils.calculate_contamination">[docs]</a>
<span class="k">def</span> <span class="nf">calculate_contamination</span><span class="p">(</span>
    <span class="n">adata</span><span class="p">:</span> <span class="n">ad</span><span class="o">.</span><span class="n">AnnData</span><span class="p">,</span> 
    <span class="n">markers</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]],</span> 
    <span class="n">radius</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">15</span><span class="p">,</span> 
    <span class="n">n_neighs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> 
    <span class="n">celltype_column</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;celltype_major&#39;</span><span class="p">,</span> 
    <span class="n">num_cells</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10000</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate normalized contamination from neighboring cells of different cell types based on positive markers.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - adata: ad.AnnData</span>
<span class="sd">        Annotated data object with raw counts and cell type information.</span>
<span class="sd">    - markers: dict</span>
<span class="sd">        Dictionary where keys are cell types and values are dictionaries containing:</span>
<span class="sd">            &#39;positive&#39;: list of top x% highly expressed genes</span>
<span class="sd">            &#39;negative&#39;: list of top x% lowly expressed genes.</span>
<span class="sd">    - radius: float, default=15</span>
<span class="sd">        Radius for spatial neighbor calculation.</span>
<span class="sd">    - n_neighs: int, default=10</span>
<span class="sd">        Maximum number of neighbors to consider.</span>
<span class="sd">    - celltype_column: str, default=&#39;celltype_major&#39;</span>
<span class="sd">        Column name in the AnnData object representing cell types.</span>
<span class="sd">    - num_cells: int, default=10000</span>
<span class="sd">        Number of cells to randomly select for the calculation.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - contamination_df: pd.DataFrame</span>
<span class="sd">        DataFrame containing the normalized level of contamination from each cell type to each other cell type.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">celltype_column</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Column celltype_column must be present in adata.obs.&quot;</span><span class="p">)</span>
    <span class="n">positive_markers</span> <span class="o">=</span> <span class="p">{</span><span class="n">ct</span><span class="p">:</span> <span class="n">markers</span><span class="p">[</span><span class="n">ct</span><span class="p">][</span><span class="s1">&#39;positive&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">ct</span> <span class="ow">in</span> <span class="n">markers</span><span class="p">}</span>
    <span class="n">adata</span><span class="o">.</span><span class="n">obsm</span><span class="p">[</span><span class="s2">&quot;spatial&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[[</span><span class="s2">&quot;cell_centroid_x&quot;</span><span class="p">,</span> <span class="s2">&quot;cell_centroid_y&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
    <span class="n">sq</span><span class="o">.</span><span class="n">gr</span><span class="o">.</span><span class="n">spatial_neighbors</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="n">radius</span><span class="p">,</span> <span class="n">n_neighs</span><span class="o">=</span><span class="n">n_neighs</span><span class="p">,</span> <span class="n">coord_type</span><span class="o">=</span><span class="s1">&#39;generic&#39;</span><span class="p">)</span>
    <span class="n">neighbors</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obsp</span><span class="p">[</span><span class="s1">&#39;spatial_connectivities&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">tolil</span><span class="p">()</span>
    <span class="n">raw_counts</span> <span class="o">=</span> <span class="n">adata</span><span class="p">[:,</span> <span class="n">adata</span><span class="o">.</span><span class="n">var_names</span><span class="p">]</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="s1">&#39;raw&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
    <span class="n">cell_types</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">celltype_column</span><span class="p">]</span>
    <span class="n">selected_cells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">n_obs</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">num_cells</span><span class="p">,</span> <span class="n">adata</span><span class="o">.</span><span class="n">n_obs</span><span class="p">),</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">contamination</span> <span class="o">=</span> <span class="p">{</span><span class="n">ct</span><span class="p">:</span> <span class="p">{</span><span class="n">ct2</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">ct2</span> <span class="ow">in</span> <span class="n">positive_markers</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span> <span class="k">for</span> <span class="n">ct</span> <span class="ow">in</span> <span class="n">positive_markers</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>
    <span class="n">negighborings</span> <span class="o">=</span> <span class="p">{</span><span class="n">ct</span><span class="p">:</span> <span class="p">{</span><span class="n">ct2</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">ct2</span> <span class="ow">in</span> <span class="n">positive_markers</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span> <span class="k">for</span> <span class="n">ct</span> <span class="ow">in</span> <span class="n">positive_markers</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>
    <span class="k">for</span> <span class="n">cell_idx</span> <span class="ow">in</span> <span class="n">selected_cells</span><span class="p">:</span>
        <span class="n">cell_type</span> <span class="o">=</span> <span class="n">cell_types</span><span class="p">[</span><span class="n">cell_idx</span><span class="p">]</span>
        <span class="n">own_markers</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">positive_markers</span><span class="p">[</span><span class="n">cell_type</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">marker</span> <span class="ow">in</span> <span class="n">own_markers</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">marker</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">var_names</span><span class="p">:</span>
                <span class="n">total_counts_in_neighborhood</span> <span class="o">=</span> <span class="n">raw_counts</span><span class="p">[</span><span class="n">cell_idx</span><span class="p">,</span> <span class="n">adata</span><span class="o">.</span><span class="n">var_names</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">marker</span><span class="p">)]</span>
                <span class="k">for</span> <span class="n">neighbor_idx</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="o">.</span><span class="n">rows</span><span class="p">[</span><span class="n">cell_idx</span><span class="p">]:</span>
                    <span class="n">total_counts_in_neighborhood</span> <span class="o">+=</span> <span class="n">raw_counts</span><span class="p">[</span><span class="n">neighbor_idx</span><span class="p">,</span> <span class="n">adata</span><span class="o">.</span><span class="n">var_names</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">marker</span><span class="p">)]</span>
                <span class="k">for</span> <span class="n">neighbor_idx</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="o">.</span><span class="n">rows</span><span class="p">[</span><span class="n">cell_idx</span><span class="p">]:</span>
                    <span class="n">neighbor_type</span> <span class="o">=</span> <span class="n">cell_types</span><span class="p">[</span><span class="n">neighbor_idx</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">cell_type</span> <span class="o">==</span> <span class="n">neighbor_type</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">neighbor_markers</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">positive_markers</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">neighbor_type</span><span class="p">,</span> <span class="p">[]))</span>
                    <span class="n">contamination_markers</span> <span class="o">=</span> <span class="n">own_markers</span> <span class="o">-</span> <span class="n">neighbor_markers</span>
                    <span class="k">for</span> <span class="n">marker</span> <span class="ow">in</span> <span class="n">contamination_markers</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">marker</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">var_names</span><span class="p">:</span>
                            <span class="n">marker_counts_in_neighbor</span> <span class="o">=</span> <span class="n">raw_counts</span><span class="p">[</span><span class="n">neighbor_idx</span><span class="p">,</span> <span class="n">adata</span><span class="o">.</span><span class="n">var_names</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">marker</span><span class="p">)]</span>
                            <span class="k">if</span> <span class="n">total_counts_in_neighborhood</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="n">contamination</span><span class="p">[</span><span class="n">cell_type</span><span class="p">][</span><span class="n">neighbor_type</span><span class="p">]</span> <span class="o">+=</span> <span class="n">marker_counts_in_neighbor</span> <span class="o">/</span> <span class="n">total_counts_in_neighborhood</span>
                                <span class="n">negighborings</span><span class="p">[</span><span class="n">cell_type</span><span class="p">][</span><span class="n">neighbor_type</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">contamination_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">contamination</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="n">negighborings_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">negighborings</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="n">contamination_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Source Cell Type&#39;</span>
    <span class="n">contamination_df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Target Cell Type&#39;</span>
    <span class="k">return</span> <span class="n">contamination_df</span> <span class="o">/</span> <span class="p">(</span><span class="n">negighborings_df</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span></div>



<div class="viewcode-block" id="calculate_sensitivity">
<a class="viewcode-back" href="../../../api/validation/utils/index.html#segger.validation.utils.calculate_sensitivity">[docs]</a>
<span class="k">def</span> <span class="nf">calculate_sensitivity</span><span class="p">(</span>
    <span class="n">adata</span><span class="p">:</span> <span class="n">ad</span><span class="o">.</span><span class="n">AnnData</span><span class="p">,</span> 
    <span class="n">purified_markers</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> 
    <span class="n">max_cells_per_type</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the sensitivity of the purified markers for each cell type.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - adata: AnnData</span>
<span class="sd">        Annotated data object containing gene expression data.</span>
<span class="sd">    - purified_markers: dict</span>
<span class="sd">        Dictionary where keys are cell types and values are lists of purified marker genes.</span>
<span class="sd">    - max_cells_per_type: int, default=1000</span>
<span class="sd">        Maximum number of cells to consider per cell type.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - sensitivity_results: dict</span>
<span class="sd">        Dictionary with cell types as keys and lists of sensitivity values for each cell.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sensitivity_results</span> <span class="o">=</span> <span class="p">{</span><span class="n">cell_type</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">cell_type</span> <span class="ow">in</span> <span class="n">purified_markers</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>
    <span class="k">for</span> <span class="n">cell_type</span><span class="p">,</span> <span class="n">markers</span> <span class="ow">in</span> <span class="n">purified_markers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">markers</span> <span class="o">=</span> <span class="n">markers</span><span class="p">[</span><span class="s1">&#39;positive&#39;</span><span class="p">]</span>
        <span class="n">subset</span> <span class="o">=</span> <span class="n">adata</span><span class="p">[</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s1">&#39;celltype_major&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">cell_type</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">subset</span><span class="o">.</span><span class="n">n_obs</span> <span class="o">&gt;</span> <span class="n">max_cells_per_type</span><span class="p">:</span>
            <span class="n">cell_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">subset</span><span class="o">.</span><span class="n">n_obs</span><span class="p">,</span> <span class="n">max_cells_per_type</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">subset</span> <span class="o">=</span> <span class="n">subset</span><span class="p">[</span><span class="n">cell_indices</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">cell_counts</span> <span class="ow">in</span> <span class="n">subset</span><span class="o">.</span><span class="n">X</span><span class="p">:</span>
            <span class="n">expressed_markers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">((</span><span class="n">cell_counts</span><span class="p">[</span><span class="n">subset</span><span class="o">.</span><span class="n">var_names</span><span class="o">.</span><span class="n">get_indexer</span><span class="p">(</span><span class="n">markers</span><span class="p">)]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
            <span class="n">sensitivity</span> <span class="o">=</span> <span class="n">expressed_markers</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">markers</span><span class="p">)</span> <span class="k">if</span> <span class="n">markers</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="n">sensitivity_results</span><span class="p">[</span><span class="n">cell_type</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sensitivity</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sensitivity_results</span></div>



<div class="viewcode-block" id="compute_clustering_scores">
<a class="viewcode-back" href="../../../api/validation/utils/index.html#segger.validation.utils.compute_clustering_scores">[docs]</a>
<span class="k">def</span> <span class="nf">compute_clustering_scores</span><span class="p">(</span>
    <span class="n">adata</span><span class="p">:</span> <span class="n">ad</span><span class="o">.</span><span class="n">AnnData</span><span class="p">,</span> 
    <span class="n">cell_type_column</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;celltype_major&#39;</span><span class="p">,</span> 
    <span class="n">use_pca</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the Calinski-Harabasz and Silhouette scores for an AnnData object based on the assigned cell types.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - adata: AnnData</span>
<span class="sd">        Annotated data object containing gene expression data and cell type assignments.</span>
<span class="sd">    - cell_type_column: str, default=&#39;celltype_major&#39;</span>
<span class="sd">        Column name in `adata.obs` that specifies cell types.</span>
<span class="sd">    - use_pca: bool, default=True</span>
<span class="sd">        Whether to use PCA components as features. If False, use the raw data.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - ch_score: float</span>
<span class="sd">        The Calinski-Harabasz score.</span>
<span class="sd">    - sh_score: float</span>
<span class="sd">        The Silhouette score.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">cell_type_column</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Column &#39;</span><span class="si">{</span><span class="n">cell_type_column</span><span class="si">}</span><span class="s2">&#39; must be present in adata.obs.&quot;</span><span class="p">)</span>
    <span class="n">features</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">X</span>
    <span class="n">cell_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">n_obs</span><span class="p">,</span> <span class="mi">10000</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">features</span> <span class="o">=</span> <span class="n">features</span><span class="p">[</span><span class="n">cell_indices</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">adata</span><span class="p">[</span><span class="n">cell_indices</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">cell_type_column</span><span class="p">]</span>
    <span class="n">ch_score</span> <span class="o">=</span> <span class="n">calinski_harabasz_score</span><span class="p">(</span><span class="n">features</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>
    <span class="n">sh_score</span> <span class="o">=</span> <span class="n">silhouette_score</span><span class="p">(</span><span class="n">features</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ch_score</span><span class="p">,</span> <span class="n">sh_score</span></div>



<div class="viewcode-block" id="compute_neighborhood_metrics">
<a class="viewcode-back" href="../../../api/validation/utils/index.html#segger.validation.utils.compute_neighborhood_metrics">[docs]</a>
<span class="k">def</span> <span class="nf">compute_neighborhood_metrics</span><span class="p">(</span>
    <span class="n">adata</span><span class="p">:</span> <span class="n">ad</span><span class="o">.</span><span class="n">AnnData</span><span class="p">,</span> 
    <span class="n">radius</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> 
    <span class="n">celltype_column</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;celltype_major&#39;</span><span class="p">,</span>
    <span class="n">n_neighs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
    <span class="n">subset_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10000</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute neighborhood entropy and number of neighbors for each cell in the AnnData object.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - adata: AnnData</span>
<span class="sd">        Annotated data object containing spatial information and cell type assignments.</span>
<span class="sd">    - radius: int, default=10</span>
<span class="sd">        Radius for spatial neighbor calculation.</span>
<span class="sd">    - celltype_column: str, default=&#39;celltype_major&#39;</span>
<span class="sd">        Column name in `adata.obs` that specifies cell types.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute neighborhood entropy and number of neighbors for a random subset of cells in the AnnData object.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - adata: AnnData</span>
<span class="sd">        Annotated data object containing spatial information and cell type assignments.</span>
<span class="sd">    - radius: int, default=10</span>
<span class="sd">        Radius for spatial neighbor calculation.</span>
<span class="sd">    - celltype_column: str, default=&#39;celltype_major&#39;</span>
<span class="sd">        Column name in `adata.obs` that specifies cell types.</span>
<span class="sd">    - subset_size: int, default=10000</span>
<span class="sd">        Number of cells to randomly select for the calculation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Ensure the subset size does not exceed the number of cells</span>
    <span class="n">subset_size</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">subset_size</span><span class="p">,</span> <span class="n">adata</span><span class="o">.</span><span class="n">n_obs</span><span class="p">)</span>
    <span class="c1"># Randomly select a subset of cells</span>
    <span class="n">subset_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">n_obs</span><span class="p">,</span> <span class="n">subset_size</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="c1"># Compute spatial neighbors for the entire dataset</span>
    <span class="n">sq</span><span class="o">.</span><span class="n">gr</span><span class="o">.</span><span class="n">spatial_neighbors</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="n">radius</span><span class="p">,</span> <span class="n">coord_type</span><span class="o">=</span><span class="s1">&#39;generic&#39;</span><span class="p">,</span> <span class="n">n_neighs</span><span class="o">=</span><span class="n">n_neighs</span><span class="p">)</span>
    <span class="n">neighbors</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obsp</span><span class="p">[</span><span class="s1">&#39;spatial_distances&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">tolil</span><span class="p">()</span><span class="o">.</span><span class="n">rows</span>
    <span class="n">entropies</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">num_neighbors</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Calculate entropy and number of neighbors only for the selected subset</span>
    <span class="k">for</span> <span class="n">cell_index</span> <span class="ow">in</span> <span class="n">subset_indices</span><span class="p">:</span>
        <span class="n">neighbor_indices</span> <span class="o">=</span> <span class="n">neighbors</span><span class="p">[</span><span class="n">cell_index</span><span class="p">]</span>
        <span class="n">neighbor_cell_types</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">celltype_column</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">neighbor_indices</span><span class="p">]</span>
        <span class="n">cell_type_counts</span> <span class="o">=</span> <span class="n">neighbor_cell_types</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span>
        <span class="n">total_neighbors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">neighbor_cell_types</span><span class="p">)</span>
        <span class="n">num_neighbors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">total_neighbors</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">total_neighbors</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">cell_type_probs</span> <span class="o">=</span> <span class="n">cell_type_counts</span> <span class="o">/</span> <span class="n">total_neighbors</span>
            <span class="n">cell_type_entropy</span> <span class="o">=</span> <span class="n">entropy</span><span class="p">(</span><span class="n">cell_type_probs</span><span class="p">)</span>
            <span class="n">entropies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cell_type_entropy</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">entropies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># Store the results back into the original AnnData object</span>
    <span class="c1"># We fill with NaN for cells not in the subset</span>
    <span class="n">entropy_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">n_obs</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    <span class="n">neighbors_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">n_obs</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    <span class="n">entropy_full</span><span class="p">[</span><span class="n">subset_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">entropies</span>
    <span class="n">neighbors_full</span><span class="p">[</span><span class="n">subset_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">num_neighbors</span>
    <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s1">&#39;neighborhood_entropy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">entropy_full</span>
    <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s1">&#39;number_of_neighbors&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">neighbors_full</span></div>



<div class="viewcode-block" id="compute_transcript_density">
<a class="viewcode-back" href="../../../api/validation/utils/index.html#segger.validation.utils.compute_transcript_density">[docs]</a>
<span class="k">def</span> <span class="nf">compute_transcript_density</span><span class="p">(</span><span class="n">adata</span><span class="p">:</span> <span class="n">ad</span><span class="o">.</span><span class="n">AnnData</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the transcript density for each cell in the AnnData object.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - adata: AnnData</span>
<span class="sd">        Annotated data object containing transcript and cell area information.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">transcript_counts</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s1">&#39;transcript_counts&#39;</span><span class="p">]</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">transcript_counts</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s1">&#39;transcripts&#39;</span><span class="p">]</span>
    <span class="n">cell_areas</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s1">&#39;cell_area&#39;</span><span class="p">]</span>
    <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s1">&#39;transcript_density&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">transcript_counts</span> <span class="o">/</span> <span class="n">cell_areas</span></div>



<span class="c1"># def compute_celltype_f1_purity(</span>
<span class="c1">#     adata: ad.AnnData, </span>
<span class="c1">#     marker_genes: Dict[str, Dict[str, List[str]]]</span>
<span class="c1"># ) -&gt; Dict[str, float]:</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     Compute the purity F1 score for each cell type based on marker genes.</span>

<span class="c1">#     Parameters:</span>
<span class="c1">#     - adata: AnnData</span>
<span class="c1">#         Annotated data object containing gene expression data.</span>
<span class="c1">#     - marker_genes: dict</span>
<span class="c1">#         Dictionary where keys are cell types and values are dictionaries containing:</span>
<span class="c1">#             &#39;positive&#39;: list of top x% highly expressed genes</span>
<span class="c1">#             &#39;negative&#39;: list of top x% lowly expressed genes.</span>

<span class="c1">#     Returns:</span>
<span class="c1">#     - f1_scores: dict</span>
<span class="c1">#         Dictionary with cell types as keys and their corresponding purity F1 scores.</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     f1_scores = {}</span>
<span class="c1">#     for cell_type, markers in marker_genes.items():</span>
<span class="c1">#         pos_markers = markers[&#39;positive&#39;]</span>
<span class="c1">#         neg_markers = markers[&#39;negative&#39;]</span>
<span class="c1">#         pos_expr = adata[:, pos_markers].X.toarray().mean(axis=1)</span>
<span class="c1">#         neg_expr = adata[:, neg_markers].X.toarray().mean(axis=1)</span>
<span class="c1">#         pos_labels = adata.obs[&#39;celltype_major&#39;] == cell_type</span>
<span class="c1">#         neg_labels = adata.obs[&#39;celltype_major&#39;] != cell_type</span>
<span class="c1">#         pos_f1 = f1_score(pos_labels, pos_expr &gt;= np.percentile(pos_expr, 97))</span>
<span class="c1">#         neg_f1 = f1_score(pos_labels, neg_expr &lt;= np.percentile(neg_expr, 10))</span>
<span class="c1">#         scaled_pos_f1 = (pos_f1 - 0) / (1 - 0)</span>
<span class="c1">#         scaled_neg_f1 = (neg_f1 - 0) / (1 - 0)</span>
<span class="c1">#         purity_f1 = 2 * (scaled_pos_f1 * scaled_neg_f1) / (scaled_pos_f1 + scaled_neg_f1)</span>
<span class="c1">#         f1_scores[cell_type] = purity_f1</span>
<span class="c1">#     return f1_scores</span>


<span class="c1"># def average_log_normalized_expression(</span>
<span class="c1">#     adata: ad.AnnData, </span>
<span class="c1">#     celltype_column: str</span>
<span class="c1"># ) -&gt; pd.DataFrame:</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     Compute the average log-normalized expression for each cell type.</span>

<span class="c1">#     Parameters:</span>
<span class="c1">#     - adata: AnnData</span>
<span class="c1">#         Annotated data object containing gene expression data.</span>
<span class="c1">#     - celltype_column: str</span>
<span class="c1">#         Column name in `adata.obs` that specifies cell types.</span>

<span class="c1">#     Returns:</span>
<span class="c1">#     - avg_expr: pd.DataFrame</span>
<span class="c1">#         DataFrame containing the average log-normalized expression for each cell type.</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     return adata.to_df().groupby(adata.obs[celltype_column]).mean()</span>






<div class="viewcode-block" id="plot_metric_comparison">
<a class="viewcode-back" href="../../../api/validation/utils/index.html#segger.validation.utils.plot_metric_comparison">[docs]</a>
<span class="k">def</span> <span class="nf">plot_metric_comparison</span><span class="p">(</span>
    <span class="n">ax</span><span class="p">:</span> <span class="n">plt</span><span class="o">.</span><span class="n">Axes</span><span class="p">,</span> 
    <span class="n">data</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> 
    <span class="n">metric</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> 
    <span class="n">label</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> 
    <span class="n">method1</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> 
    <span class="n">method2</span><span class="p">:</span> <span class="nb">str</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plot a comparison of a specific metric between two methods.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - ax: plt.Axes</span>
<span class="sd">        Matplotlib axis to plot on.</span>
<span class="sd">    - data: pd.DataFrame</span>
<span class="sd">        DataFrame containing the data for plotting.</span>
<span class="sd">    - metric: str</span>
<span class="sd">        The metric to compare.</span>
<span class="sd">    - label: str</span>
<span class="sd">        Label for the metric.</span>
<span class="sd">    - method1: str</span>
<span class="sd">        The first method to compare.</span>
<span class="sd">    - method2: str</span>
<span class="sd">        The second method to compare.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">subset1</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;method&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">method1</span><span class="p">]</span>
    <span class="n">subset2</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;method&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">method2</span><span class="p">]</span>
    <span class="n">merged_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">subset1</span><span class="p">,</span> <span class="n">subset2</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s1">&#39;celltype_major&#39;</span><span class="p">,</span> <span class="n">suffixes</span><span class="o">=</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;_</span><span class="si">{</span><span class="n">method1</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;_</span><span class="si">{</span><span class="n">method2</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">cell_type</span> <span class="ow">in</span> <span class="n">merged_data</span><span class="p">[</span><span class="s1">&#39;celltype_major&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>
        <span class="n">cell_data</span> <span class="o">=</span> <span class="n">merged_data</span><span class="p">[</span><span class="n">merged_data</span><span class="p">[</span><span class="s1">&#39;celltype_major&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">cell_type</span><span class="p">]</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">cell_data</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">metric</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">method1</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">],</span> <span class="n">cell_data</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">metric</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">method2</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">],</span> 
                   <span class="n">label</span><span class="o">=</span><span class="n">cell_type</span><span class="p">)</span>
    <span class="n">max_value</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">merged_data</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">metric</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">method1</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">merged_data</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">metric</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">method2</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_value</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_value</span><span class="p">],</span> <span class="s1">&#39;k--&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s1"> (</span><span class="si">{</span><span class="n">method1</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s1"> (</span><span class="si">{</span><span class="n">method2</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="n">method1</span><span class="si">}</span><span class="s1"> vs </span><span class="si">{</span><span class="n">method2</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span></div>




<div class="viewcode-block" id="load_segmentations">
<a class="viewcode-back" href="../../../api/validation/utils/index.html#segger.validation.utils.load_segmentations">[docs]</a>
<span class="k">def</span> <span class="nf">load_segmentations</span><span class="p">(</span><span class="n">segmentation_paths</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">sc</span><span class="o">.</span><span class="n">AnnData</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load segmentation data from provided paths and handle special cases like separating &#39;segger&#39; into &#39;segger_n0&#39; and &#39;segger_n1&#39;.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    segmentation_paths (Dict[str, Path]): Dictionary mapping segmentation method names to their file paths.</span>

<span class="sd">    Returns:</span>
<span class="sd">    Dict[str, sc.AnnData]: Dictionary mapping segmentation method names to loaded AnnData objects.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">segmentations_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">method</span><span class="p">,</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">segmentation_paths</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">adata</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="c1"># Special handling for &#39;segger&#39; to separate into &#39;segger_n0&#39; and &#39;segger_n1&#39;</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;segger&#39;</span><span class="p">:</span>
            <span class="n">cells_n1</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs_names</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">i</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;-nx&#39;</span><span class="p">)]</span>
            <span class="n">cells_n0</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs_names</span> <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;-nx&#39;</span><span class="p">)]</span>
            <span class="n">segmentations_dict</span><span class="p">[</span><span class="s1">&#39;segger_n1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">adata</span><span class="p">[</span><span class="n">cells_n1</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">segmentations_dict</span><span class="p">[</span><span class="s1">&#39;segger_n0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">adata</span><span class="p">[</span><span class="n">cells_n0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">segmentations_dict</span><span class="p">[</span><span class="n">method</span><span class="p">]</span> <span class="o">=</span> <span class="n">adata</span>
    <span class="k">return</span> <span class="n">segmentations_dict</span></div>




<div class="viewcode-block" id="plot_cell_counts">
<a class="viewcode-back" href="../../../api/validation/utils/index.html#segger.validation.utils.plot_cell_counts">[docs]</a>
<span class="k">def</span> <span class="nf">plot_cell_counts</span><span class="p">(</span><span class="n">segmentations_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">sc</span><span class="o">.</span><span class="n">AnnData</span><span class="p">],</span> <span class="n">output_path</span><span class="p">:</span> <span class="n">Path</span><span class="p">,</span> <span class="n">palette</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plot the number of cells per segmentation method.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    segmentations_dict (Dict[str, sc.AnnData]): Dictionary mapping segmentation method names to loaded AnnData objects.</span>
<span class="sd">    output_path (Path): Path to the directory where the plot will be saved.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Calculate the number of cells in each segmentation method</span>
    <span class="n">cell_counts</span> <span class="o">=</span> <span class="p">{</span><span class="n">method</span><span class="p">:</span> <span class="n">seg</span><span class="o">.</span><span class="n">n_obs</span> <span class="k">for</span> <span class="n">method</span><span class="p">,</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">segmentations_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    
    <span class="c1"># Create a DataFrame for the bar plot</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">cell_counts</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Number of Cells&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
    
    <span class="c1"># Generate the bar plot</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="n">stacked</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="n">palette</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s1">&#39;#333333&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">],</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="n">width</span><span class="o">=</span><span class="mf">0.9</span><span class="p">)</span>
    
    <span class="c1"># Add a dashed line for the 10X baseline</span>
    <span class="k">if</span> <span class="s1">&#39;10X&#39;</span> <span class="ow">in</span> <span class="n">cell_counts</span><span class="p">:</span>
        <span class="n">baseline_height</span> <span class="o">=</span> <span class="n">cell_counts</span><span class="p">[</span><span class="s1">&#39;10X&#39;</span><span class="p">]</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">baseline_height</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;10X Baseline&#39;</span><span class="p">)</span>
    
    <span class="c1"># Set plot titles and labels</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Number of Cells per Segmentation Method&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Segmentation Method&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Number of Cells&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">bbox_to_anchor</span><span class="o">=</span><span class="p">(</span><span class="mf">1.05</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="s1">&#39;upper left&#39;</span><span class="p">)</span>
    
    <span class="c1"># Save the figure as a PDF</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">output_path</span> <span class="o">/</span> <span class="s1">&#39;cell_counts_bar_plot.pdf&#39;</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="plot_percent_assigned">
<a class="viewcode-back" href="../../../api/validation/utils/index.html#segger.validation.utils.plot_percent_assigned">[docs]</a>
<span class="k">def</span> <span class="nf">plot_percent_assigned</span><span class="p">(</span><span class="n">segmentations_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">sc</span><span class="o">.</span><span class="n">AnnData</span><span class="p">],</span> <span class="n">output_path</span><span class="p">:</span> <span class="n">Path</span><span class="p">,</span> <span class="n">palette</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plot the percentage of assigned transcripts (normalized) for each segmentation method.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    segmentations_dict (Dict[str, sc.AnnData]): Dictionary mapping segmentation method names to loaded AnnData objects.</span>
<span class="sd">    output_path (Path): Path to the directory where the plot will be saved.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Calculate total counts per gene for each segmentation method</span>
    <span class="n">total_counts_per_gene</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">method</span><span class="p">,</span> <span class="n">adata</span> <span class="ow">in</span> <span class="n">segmentations_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">gene_counts</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>  <span class="c1"># Sum across cells for each gene and flatten to 1D</span>
        <span class="n">gene_counts</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">gene_counts</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">adata</span><span class="o">.</span><span class="n">var_names</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
        <span class="n">total_counts_per_gene</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">total_counts_per_gene</span><span class="p">,</span> <span class="n">gene_counts</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Normalize by the maximum count per gene across all segmentations</span>
    <span class="n">max_counts_per_gene</span> <span class="o">=</span> <span class="n">total_counts_per_gene</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">percent_assigned_normalized</span> <span class="o">=</span> <span class="n">total_counts_per_gene</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">max_counts_per_gene</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span>

    <span class="c1"># Prepare the data for the violin plot</span>
    <span class="n">violin_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
        <span class="s1">&#39;Segmentation Method&#39;</span><span class="p">:</span> <span class="p">[],</span>
        <span class="s1">&#39;Percent Assigned (Normalized)&#39;</span><span class="p">:</span> <span class="p">[]</span>
    <span class="p">})</span>

    <span class="c1"># Add normalized percent_assigned data for each method</span>
    <span class="k">for</span> <span class="n">method</span> <span class="ow">in</span> <span class="n">segmentations_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">method_data</span> <span class="o">=</span> <span class="n">percent_assigned_normalized</span><span class="p">[</span><span class="n">method</span><span class="p">]</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>
        <span class="n">method_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
            <span class="s1">&#39;Segmentation Method&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">method</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">method_data</span><span class="p">),</span>
            <span class="s1">&#39;Percent Assigned (Normalized)&#39;</span><span class="p">:</span> <span class="n">method_data</span><span class="o">.</span><span class="n">values</span>
        <span class="p">})</span>
        <span class="n">violin_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">violin_data</span><span class="p">,</span> <span class="n">method_df</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Plot the violin plots</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">violinplot</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="s1">&#39;Segmentation Method&#39;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s1">&#39;Percent Assigned (Normalized)&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">violin_data</span><span class="p">,</span> <span class="n">palette</span><span class="o">=</span><span class="n">palette</span><span class="p">)</span>

    <span class="c1"># Add a dashed line for the 10X baseline</span>
    <span class="k">if</span> <span class="s1">&#39;10X&#39;</span> <span class="ow">in</span> <span class="n">segmentations_dict</span><span class="p">:</span>
        <span class="n">baseline_height</span> <span class="o">=</span> <span class="n">percent_assigned_normalized</span><span class="p">[</span><span class="s1">&#39;10X&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">baseline_height</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;10X Baseline&#39;</span><span class="p">)</span>

    <span class="c1"># Set plot titles and labels</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Segmentation Method&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Percent Assigned (Normalized)&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">bbox_to_anchor</span><span class="o">=</span><span class="p">(</span><span class="mf">1.05</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="s1">&#39;upper left&#39;</span><span class="p">)</span>

    <span class="c1"># Save the figure as a PDF</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">output_path</span> <span class="o">/</span> <span class="s1">&#39;percent_assigned_normalized_violin_plot.pdf&#39;</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="plot_gene_counts">
<a class="viewcode-back" href="../../../api/validation/utils/index.html#segger.validation.utils.plot_gene_counts">[docs]</a>
<span class="k">def</span> <span class="nf">plot_gene_counts</span><span class="p">(</span><span class="n">segmentations_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">sc</span><span class="o">.</span><span class="n">AnnData</span><span class="p">],</span> <span class="n">output_path</span><span class="p">:</span> <span class="n">Path</span><span class="p">,</span> <span class="n">palette</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plot the normalized gene counts for each segmentation method.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    segmentations_dict (Dict[str, sc.AnnData]): Dictionary mapping segmentation method names to loaded AnnData objects.</span>
<span class="sd">    output_path (Path): Path to the directory where the plot will be saved.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Calculate total counts per gene for each segmentation method</span>
    <span class="n">total_counts_per_gene</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">method</span><span class="p">,</span> <span class="n">adata</span> <span class="ow">in</span> <span class="n">segmentations_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">gene_counts</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">gene_counts</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">gene_counts</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">adata</span><span class="o">.</span><span class="n">var_names</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
        <span class="n">total_counts_per_gene</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">total_counts_per_gene</span><span class="p">,</span> <span class="n">gene_counts</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Normalize by the maximum count per gene across all segmentations</span>
    <span class="n">max_counts_per_gene</span> <span class="o">=</span> <span class="n">total_counts_per_gene</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">normalized_counts_per_gene</span> <span class="o">=</span> <span class="n">total_counts_per_gene</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">max_counts_per_gene</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Prepare the data for the box plot</span>
    <span class="n">boxplot_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
        <span class="s1">&#39;Segmentation Method&#39;</span><span class="p">:</span> <span class="p">[],</span>
        <span class="s1">&#39;Normalized Counts&#39;</span><span class="p">:</span> <span class="p">[]</span>
    <span class="p">})</span>

    <span class="k">for</span> <span class="n">method</span> <span class="ow">in</span> <span class="n">segmentations_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">method_counts</span> <span class="o">=</span> <span class="n">normalized_counts_per_gene</span><span class="p">[</span><span class="n">method</span><span class="p">]</span>
        <span class="n">method_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
            <span class="s1">&#39;Segmentation Method&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">method</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">method_counts</span><span class="p">),</span>
            <span class="s1">&#39;Normalized Counts&#39;</span><span class="p">:</span> <span class="n">method_counts</span><span class="o">.</span><span class="n">values</span>
        <span class="p">})</span>
        <span class="n">boxplot_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">boxplot_data</span><span class="p">,</span> <span class="n">method_df</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Plot the box plots</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">boxplot</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="s1">&#39;Segmentation Method&#39;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s1">&#39;Normalized Counts&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">boxplot_data</span><span class="p">,</span> <span class="n">palette</span><span class="o">=</span><span class="n">palette</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mf">0.9</span><span class="p">)</span>

    <span class="c1"># Add a dashed line for the 10X baseline</span>
    <span class="k">if</span> <span class="s1">&#39;10X&#39;</span> <span class="ow">in</span> <span class="n">normalized_counts_per_gene</span><span class="p">:</span>
        <span class="n">baseline_height</span> <span class="o">=</span> <span class="n">normalized_counts_per_gene</span><span class="p">[</span><span class="s1">&#39;10X&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">baseline_height</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;10X Baseline&#39;</span><span class="p">)</span>

    <span class="c1"># Set plot titles and labels</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Segmentation Method&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Normalized Counts&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">rotation</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Save the figure as a PDF</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">output_path</span> <span class="o">/</span> <span class="s1">&#39;gene_counts_normalized_boxplot_by_method.pdf&#39;</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="plot_counts_per_cell">
<a class="viewcode-back" href="../../../api/validation/utils/index.html#segger.validation.utils.plot_counts_per_cell">[docs]</a>
<span class="k">def</span> <span class="nf">plot_counts_per_cell</span><span class="p">(</span><span class="n">segmentations_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">sc</span><span class="o">.</span><span class="n">AnnData</span><span class="p">],</span> <span class="n">output_path</span><span class="p">:</span> <span class="n">Path</span><span class="p">,</span> <span class="n">palette</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plot the counts per cell (log2) for each segmentation method.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    segmentations_dict (Dict[str, sc.AnnData]): Dictionary mapping segmentation method names to loaded AnnData objects.</span>
<span class="sd">    output_path (Path): Path to the directory where the plot will be saved.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Prepare the data for the violin plot</span>
    <span class="n">violin_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
        <span class="s1">&#39;Segmentation Method&#39;</span><span class="p">:</span> <span class="p">[],</span>
        <span class="s1">&#39;Counts per Cell (log2)&#39;</span><span class="p">:</span> <span class="p">[]</span>
    <span class="p">})</span>
    <span class="k">for</span> <span class="n">method</span><span class="p">,</span> <span class="n">adata</span> <span class="ow">in</span> <span class="n">segmentations_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">method_counts</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s1">&#39;transcripts&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">method_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
            <span class="s1">&#39;Segmentation Method&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">method</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">method_counts</span><span class="p">),</span>
            <span class="s1">&#39;Counts per Cell (log2)&#39;</span><span class="p">:</span> <span class="n">method_counts</span><span class="o">.</span><span class="n">values</span>
        <span class="p">})</span>
        <span class="n">violin_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">violin_data</span><span class="p">,</span> <span class="n">method_df</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># Plot the violin plots</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">violinplot</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="s1">&#39;Segmentation Method&#39;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s1">&#39;Counts per Cell (log2)&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">violin_data</span><span class="p">,</span> <span class="n">palette</span><span class="o">=</span><span class="n">palette</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">ylim</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">300</span><span class="p">))</span>
    <span class="c1"># Add a dashed line for the 10X-nucleus median</span>
    <span class="k">if</span> <span class="s1">&#39;10X-nucleus&#39;</span> <span class="ow">in</span> <span class="n">segmentations_dict</span><span class="p">:</span>
        <span class="n">median_10X_nucleus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">segmentations_dict</span><span class="p">[</span><span class="s1">&#39;10X-nucleus&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s1">&#39;transcripts&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">median_10X_nucleus</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;10X-nucleus Median&#39;</span><span class="p">)</span>
    <span class="c1"># Set plot titles and labels</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Segmentation Method&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Counts per Cell (log2)&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">rotation</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># Save the figure as a PDF</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">output_path</span> <span class="o">/</span> <span class="s1">&#39;counts_per_cell_violin_plot.pdf&#39;</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="plot_cell_area">
<a class="viewcode-back" href="../../../api/validation/utils/index.html#segger.validation.utils.plot_cell_area">[docs]</a>
<span class="k">def</span> <span class="nf">plot_cell_area</span><span class="p">(</span><span class="n">segmentations_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">sc</span><span class="o">.</span><span class="n">AnnData</span><span class="p">],</span> <span class="n">output_path</span><span class="p">:</span> <span class="n">Path</span><span class="p">,</span> <span class="n">palette</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plot the cell area (log2) for each segmentation method.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    segmentations_dict (Dict[str, sc.AnnData]): Dictionary mapping segmentation method names to loaded AnnData objects.</span>
<span class="sd">    output_path (Path): Path to the directory where the plot will be saved.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Prepare the data for the violin plot</span>
    <span class="n">violin_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
        <span class="s1">&#39;Segmentation Method&#39;</span><span class="p">:</span> <span class="p">[],</span>
        <span class="s1">&#39;Cell Area (log2)&#39;</span><span class="p">:</span> <span class="p">[]</span>
    <span class="p">})</span>
    <span class="k">for</span> <span class="n">method</span> <span class="ow">in</span> <span class="n">segmentations_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">if</span> <span class="s1">&#39;cell_area&#39;</span> <span class="ow">in</span> <span class="n">segmentations_dict</span><span class="p">[</span><span class="n">method</span><span class="p">]</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">method_area</span> <span class="o">=</span> <span class="n">segmentations_dict</span><span class="p">[</span><span class="n">method</span><span class="p">]</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s1">&#39;cell_area&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">method_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
                <span class="s1">&#39;Segmentation Method&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">method</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">method_area</span><span class="p">),</span>
                <span class="s1">&#39;Cell Area (log2)&#39;</span><span class="p">:</span> <span class="n">method_area</span><span class="o">.</span><span class="n">values</span>
            <span class="p">})</span>
            <span class="n">violin_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">violin_data</span><span class="p">,</span> <span class="n">method_df</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># Plot the violin plots</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">violinplot</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="s1">&#39;Segmentation Method&#39;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s1">&#39;Cell Area (log2)&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">violin_data</span><span class="p">,</span> <span class="n">palette</span><span class="o">=</span><span class="n">palette</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">ylim</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span>
    <span class="c1"># Add a dashed line for the 10X-nucleus median</span>
    <span class="k">if</span> <span class="s1">&#39;10X-nucleus&#39;</span> <span class="ow">in</span> <span class="n">segmentations_dict</span><span class="p">:</span>
        <span class="n">median_10X_nucleus_area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">segmentations_dict</span><span class="p">[</span><span class="s1">&#39;10X-nucleus&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s1">&#39;cell_area&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">median_10X_nucleus_area</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;10X-nucleus Median&#39;</span><span class="p">)</span>
    <span class="c1"># Set plot titles and labels</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Segmentation Method&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Cell Area (log2)&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">rotation</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># Save the figure as a PDF</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">output_path</span> <span class="o">/</span> <span class="s1">&#39;cell_area_log2_violin_plot.pdf&#39;</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="plot_transcript_density">
<a class="viewcode-back" href="../../../api/validation/utils/index.html#segger.validation.utils.plot_transcript_density">[docs]</a>
<span class="k">def</span> <span class="nf">plot_transcript_density</span><span class="p">(</span><span class="n">segmentations_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">sc</span><span class="o">.</span><span class="n">AnnData</span><span class="p">],</span> <span class="n">output_path</span><span class="p">:</span> <span class="n">Path</span><span class="p">,</span> <span class="n">palette</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plot the transcript density (log2) for each segmentation method.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    segmentations_dict (Dict[str, sc.AnnData]): Dictionary mapping segmentation method names to loaded AnnData objects.</span>
<span class="sd">    output_path (Path): Path to the directory where the plot will be saved.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Prepare the data for the violin plot</span>
    <span class="n">violin_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
        <span class="s1">&#39;Segmentation Method&#39;</span><span class="p">:</span> <span class="p">[],</span>
        <span class="s1">&#39;Transcript Density (log2)&#39;</span><span class="p">:</span> <span class="p">[]</span>
    <span class="p">})</span>

    <span class="k">for</span> <span class="n">method</span> <span class="ow">in</span> <span class="n">segmentations_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">if</span> <span class="s1">&#39;cell_area&#39;</span> <span class="ow">in</span> <span class="n">segmentations_dict</span><span class="p">[</span><span class="n">method</span><span class="p">]</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">method_density</span> <span class="o">=</span> <span class="n">segmentations_dict</span><span class="p">[</span><span class="n">method</span><span class="p">]</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s1">&#39;transcripts&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">segmentations_dict</span><span class="p">[</span><span class="n">method</span><span class="p">]</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s1">&#39;cell_area&#39;</span><span class="p">]</span>
            <span class="n">method_density_log2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">method_density</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">method_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
                <span class="s1">&#39;Segmentation Method&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">method</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">method_density_log2</span><span class="p">),</span>
                <span class="s1">&#39;Transcript Density (log2)&#39;</span><span class="p">:</span> <span class="n">method_density_log2</span><span class="o">.</span><span class="n">values</span>
            <span class="p">})</span>
            <span class="n">violin_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">violin_data</span><span class="p">,</span> <span class="n">method_df</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Plot the violin plots</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">violinplot</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="s1">&#39;Segmentation Method&#39;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s1">&#39;Transcript Density (log2)&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">violin_data</span><span class="p">,</span> <span class="n">palette</span><span class="o">=</span><span class="n">palette</span><span class="p">)</span>

    <span class="c1"># Add a dashed line for the 10X-nucleus median</span>
    <span class="k">if</span> <span class="s1">&#39;10X-nucleus&#39;</span> <span class="ow">in</span> <span class="n">segmentations_dict</span><span class="p">:</span>
        <span class="n">median_10X_nucleus_density_log2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">segmentations_dict</span><span class="p">[</span><span class="s1">&#39;10X-nucleus&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s1">&#39;transcripts&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">segmentations_dict</span><span class="p">[</span><span class="s1">&#39;10X-nucleus&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s1">&#39;cell_area&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">median_10X_nucleus_density_log2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;10X-nucleus Median&#39;</span><span class="p">)</span>

    <span class="c1"># Set plot titles and labels</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Segmentation Method&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Transcript Density (log2)&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">rotation</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Save the figure as a PDF</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">output_path</span> <span class="o">/</span> <span class="s1">&#39;transcript_density_log2_violin_plot.pdf&#39;</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="plot_general_statistics_plots">
<a class="viewcode-back" href="../../../api/validation/utils/index.html#segger.validation.utils.plot_general_statistics_plots">[docs]</a>
<span class="k">def</span> <span class="nf">plot_general_statistics_plots</span><span class="p">(</span><span class="n">segmentations_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">sc</span><span class="o">.</span><span class="n">AnnData</span><span class="p">],</span> <span class="n">output_path</span><span class="p">:</span> <span class="n">Path</span><span class="p">,</span> <span class="n">palette</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a summary plot with all the general statistics subplots.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    segmentations_dict (Dict[str, sc.AnnData]): Dictionary mapping segmentation method names to loaded AnnData objects.</span>
<span class="sd">    output_path (Path): Path to the directory where the summary plot will be saved.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">plot_cell_counts</span><span class="p">(</span><span class="n">segmentations_dict</span><span class="p">,</span> <span class="n">output_path</span><span class="p">,</span> <span class="n">palette</span><span class="o">=</span><span class="n">palette</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">plot_percent_assigned</span><span class="p">(</span><span class="n">segmentations_dict</span><span class="p">,</span> <span class="n">output_path</span><span class="p">,</span> <span class="n">palette</span><span class="o">=</span><span class="n">palette</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">plot_gene_counts</span><span class="p">(</span><span class="n">segmentations_dict</span><span class="p">,</span> <span class="n">output_path</span><span class="p">,</span> <span class="n">palette</span><span class="o">=</span><span class="n">palette</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
    <span class="n">plot_counts_per_cell</span><span class="p">(</span><span class="n">segmentations_dict</span><span class="p">,</span> <span class="n">output_path</span><span class="p">,</span> <span class="n">palette</span><span class="o">=</span><span class="n">palette</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
    <span class="n">plot_cell_area</span><span class="p">(</span><span class="n">segmentations_dict</span><span class="p">,</span> <span class="n">output_path</span><span class="p">,</span> <span class="n">palette</span><span class="o">=</span><span class="n">palette</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
    <span class="n">plot_transcript_density</span><span class="p">(</span><span class="n">segmentations_dict</span><span class="p">,</span> <span class="n">output_path</span><span class="p">,</span> <span class="n">palette</span><span class="o">=</span><span class="n">palette</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">output_path</span> <span class="o">/</span> <span class="s1">&#39;general_statistics_plots.pdf&#39;</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>



<div class="viewcode-block" id="plot_mecr_results">
<a class="viewcode-back" href="../../../api/validation/utils/index.html#segger.validation.utils.plot_mecr_results">[docs]</a>
<span class="k">def</span> <span class="nf">plot_mecr_results</span><span class="p">(</span><span class="n">mecr_results</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="nb">float</span><span class="p">]],</span> <span class="n">output_path</span><span class="p">:</span> <span class="n">Path</span><span class="p">,</span> <span class="n">palette</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plot the MECR (Mutually Exclusive Co-expression Rate) results for each segmentation method.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    mecr_results (Dict[str, Dict[Tuple[str, str], float]]): Dictionary of MECR results for each segmentation method.</span>
<span class="sd">    output_path (Path): Path to the directory where the plot will be saved.</span>
<span class="sd">    palette (Dict[str, str]): Dictionary mapping segmentation method names to color codes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Prepare the data for plotting</span>
    <span class="n">plot_data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">method</span><span class="p">,</span> <span class="n">mecr_dict</span> <span class="ow">in</span> <span class="n">mecr_results</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">gene_pair</span><span class="p">,</span> <span class="n">mecr_value</span> <span class="ow">in</span> <span class="n">mecr_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">plot_data</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                <span class="s1">&#39;Segmentation Method&#39;</span><span class="p">:</span> <span class="n">method</span><span class="p">,</span>
                <span class="s1">&#39;Gene Pair&#39;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">gene_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> - </span><span class="si">{</span><span class="n">gene_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="s1">&#39;MECR&#39;</span><span class="p">:</span> <span class="n">mecr_value</span>
            <span class="p">})</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">plot_data</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
    <span class="n">sns</span><span class="o">.</span><span class="n">boxplot</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="s1">&#39;Segmentation Method&#39;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s1">&#39;MECR&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">df</span><span class="p">,</span> <span class="n">palette</span><span class="o">=</span><span class="n">palette</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Mutually Exclusive Co-expression Rate (MECR)&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Segmentation Method&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;MECR&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">rotation</span><span class="o">=</span><span class="mi">45</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">output_path</span> <span class="o">/</span> <span class="s1">&#39;mecr_results_boxplot.pdf&#39;</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>

    


<div class="viewcode-block" id="plot_quantized_mecr_counts">
<a class="viewcode-back" href="../../../api/validation/utils/index.html#segger.validation.utils.plot_quantized_mecr_counts">[docs]</a>
<span class="k">def</span> <span class="nf">plot_quantized_mecr_counts</span><span class="p">(</span><span class="n">quantized_mecr_counts</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">],</span> <span class="n">output_path</span><span class="p">:</span> <span class="n">Path</span><span class="p">,</span> <span class="n">palette</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plot the quantized MECR values against transcript counts for each segmentation method, with point size proportional to the variance of MECR.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    quantized_mecr_counts (Dict[str, pd.DataFrame]): Dictionary of quantized MECR count data for each segmentation method.</span>
<span class="sd">    output_path (Path): Path to the directory where the plot will be saved.</span>
<span class="sd">    palette (Dict[str, str]): Dictionary mapping segmentation method names to color codes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">method</span><span class="p">,</span> <span class="n">df</span> <span class="ow">in</span> <span class="n">quantized_mecr_counts</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="n">df</span><span class="p">[</span><span class="s1">&#39;average_counts&#39;</span><span class="p">],</span> 
            <span class="n">df</span><span class="p">[</span><span class="s1">&#39;average_mecr&#39;</span><span class="p">],</span> 
            <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">,</span> 
            <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> 
            <span class="n">color</span><span class="o">=</span><span class="n">palette</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="s1">&#39;#333333&#39;</span><span class="p">),</span> 
            <span class="n">label</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">markersize</span><span class="o">=</span><span class="mi">0</span>  <span class="c1"># No markers, only lines</span>
        <span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
            <span class="n">df</span><span class="p">[</span><span class="s1">&#39;average_counts&#39;</span><span class="p">],</span> 
            <span class="n">df</span><span class="p">[</span><span class="s1">&#39;average_mecr&#39;</span><span class="p">],</span> 
            <span class="n">s</span><span class="o">=</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;variance_mecr&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1e5</span><span class="p">,</span>  <span class="c1"># Size of points based on the variance of MECR</span>
            <span class="n">color</span><span class="o">=</span><span class="n">palette</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="s1">&#39;#333333&#39;</span><span class="p">),</span> 
            <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span>  <span class="c1"># Slight transparency for overlapping points</span>
            <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">,</span>  <span class="c1"># White edge color for better visibility</span>
            <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.5</span>  <span class="c1"># Thin edge line</span>
        <span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Quantized MECR by Transcript Counts&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Average Transcript Counts&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Average MECR&#39;</span><span class="p">)</span>
    <span class="c1"># Place the legend outside the plot on the top right</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">bbox_to_anchor</span><span class="o">=</span><span class="p">(</span><span class="mf">1.05</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="s1">&#39;upper left&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">output_path</span> <span class="o">/</span> <span class="s1">&#39;quantized_mecr_counts_plot.pdf&#39;</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>

    
    
<div class="viewcode-block" id="plot_quantized_mecr_area">
<a class="viewcode-back" href="../../../api/validation/utils/index.html#segger.validation.utils.plot_quantized_mecr_area">[docs]</a>
<span class="k">def</span> <span class="nf">plot_quantized_mecr_area</span><span class="p">(</span><span class="n">quantized_mecr_area</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">],</span> <span class="n">output_path</span><span class="p">:</span> <span class="n">Path</span><span class="p">,</span> <span class="n">palette</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plot the quantized MECR values against cell areas for each segmentation method, with point size proportional to the variance of MECR.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    quantized_mecr_area (Dict[str, pd.DataFrame]): Dictionary of quantized MECR area data for each segmentation method.</span>
<span class="sd">    output_path (Path): Path to the directory where the plot will be saved.</span>
<span class="sd">    palette (Dict[str, str]): Dictionary mapping segmentation method names to color codes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">method</span><span class="p">,</span> <span class="n">df</span> <span class="ow">in</span> <span class="n">quantized_mecr_area</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="n">df</span><span class="p">[</span><span class="s1">&#39;average_area&#39;</span><span class="p">],</span> 
            <span class="n">df</span><span class="p">[</span><span class="s1">&#39;average_mecr&#39;</span><span class="p">],</span> 
            <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">,</span> 
            <span class="c1"># s=df[&#39;variance_mecr&#39;]  * 1e5,</span>
            <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> 
            <span class="n">color</span><span class="o">=</span><span class="n">palette</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="s1">&#39;#333333&#39;</span><span class="p">),</span> 
            <span class="n">label</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">markersize</span><span class="o">=</span><span class="mi">0</span>
        <span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
            <span class="n">df</span><span class="p">[</span><span class="s1">&#39;average_area&#39;</span><span class="p">],</span> 
            <span class="n">df</span><span class="p">[</span><span class="s1">&#39;average_mecr&#39;</span><span class="p">],</span> 
            <span class="n">s</span><span class="o">=</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;variance_mecr&#39;</span><span class="p">]</span>  <span class="o">*</span> <span class="mf">1e5</span><span class="p">,</span>  <span class="c1"># Size of points based on the variance of MECR</span>
            <span class="n">color</span><span class="o">=</span><span class="n">palette</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="s1">&#39;#333333&#39;</span><span class="p">),</span> 
            <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span>  <span class="c1"># Slight transparency for overlapping points</span>
            <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">,</span>  <span class="c1"># White edge color for better visibility</span>
            <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.5</span>  <span class="c1"># Thin edge line</span>
        <span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Quantized MECR by Cell Area&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Average Cell Area&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Average MECR&#39;</span><span class="p">)</span>
    <span class="c1"># Place the legend outside the plot on the top right</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">bbox_to_anchor</span><span class="o">=</span><span class="p">(</span><span class="mf">1.05</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="s1">&#39;upper left&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">output_path</span> <span class="o">/</span> <span class="s1">&#39;quantized_mecr_area_plot.pdf&#39;</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>

    


<div class="viewcode-block" id="plot_contamination_results">
<a class="viewcode-back" href="../../../api/validation/utils/index.html#segger.validation.utils.plot_contamination_results">[docs]</a>
<span class="k">def</span> <span class="nf">plot_contamination_results</span><span class="p">(</span><span class="n">contamination_results</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">],</span> <span class="n">output_path</span><span class="p">:</span> <span class="n">Path</span><span class="p">,</span> <span class="n">palette</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plot contamination results for each segmentation method.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    contamination_results (Dict[str, pd.DataFrame]): Dictionary of contamination data for each segmentation method.</span>
<span class="sd">    output_path (Path): Path to the directory where the plot will be saved.</span>
<span class="sd">    palette (Dict[str, str]): Dictionary mapping segmentation method names to color codes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">method</span><span class="p">,</span> <span class="n">df</span> <span class="ow">in</span> <span class="n">contamination_results</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
        <span class="n">sns</span><span class="o">.</span><span class="n">heatmap</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">annot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;coolwarm&#39;</span><span class="p">,</span> <span class="n">linewidths</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Contamination Matrix for </span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Target Cell Type&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Source Cell Type&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">output_path</span> <span class="o">/</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s1">_contamination_matrix.pdf&#39;</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>

        
        
<div class="viewcode-block" id="plot_contamination_boxplots">
<a class="viewcode-back" href="../../../api/validation/utils/index.html#segger.validation.utils.plot_contamination_boxplots">[docs]</a>
<span class="k">def</span> <span class="nf">plot_contamination_boxplots</span><span class="p">(</span><span class="n">boxplot_data</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">output_path</span><span class="p">:</span> <span class="n">Path</span><span class="p">,</span> <span class="n">palette</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plot boxplots for contamination values across different segmentation methods.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    boxplot_data (pd.DataFrame): DataFrame containing contamination data for all segmentation methods.</span>
<span class="sd">    output_path (Path): Path to the directory where the plot will be saved.</span>
<span class="sd">    palette (Dict[str, str]): Dictionary mapping segmentation method names to color codes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
    <span class="n">sns</span><span class="o">.</span><span class="n">boxplot</span><span class="p">(</span>
        <span class="n">x</span><span class="o">=</span><span class="s1">&#39;Source Cell Type&#39;</span><span class="p">,</span> 
        <span class="n">y</span><span class="o">=</span><span class="s1">&#39;Contamination&#39;</span><span class="p">,</span> 
        <span class="n">hue</span><span class="o">=</span><span class="s1">&#39;Segmentation Method&#39;</span><span class="p">,</span> 
        <span class="n">data</span><span class="o">=</span><span class="n">boxplot_data</span><span class="p">,</span> 
        <span class="n">palette</span><span class="o">=</span><span class="n">palette</span>
    <span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Neighborhood Contamination&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Source Cell Type&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Contamination&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">bbox_to_anchor</span><span class="o">=</span><span class="p">(</span><span class="mf">1.05</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="s1">&#39;upper left&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">rotation</span><span class="o">=</span><span class="mi">45</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
    
    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">output_path</span> <span class="o">/</span> <span class="s1">&#39;contamination_boxplots.pdf&#39;</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>

    
    
<div class="viewcode-block" id="plot_umaps_with_scores">
<a class="viewcode-back" href="../../../api/validation/utils/index.html#segger.validation.utils.plot_umaps_with_scores">[docs]</a>
<span class="k">def</span> <span class="nf">plot_umaps_with_scores</span><span class="p">(</span>
    <span class="n">segmentations_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">sc</span><span class="o">.</span><span class="n">AnnData</span><span class="p">],</span> 
    <span class="n">clustering_scores</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]],</span> 
    <span class="n">output_path</span><span class="p">:</span> <span class="n">Path</span><span class="p">,</span> 
    <span class="n">palette</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plot UMAPs colored by cell type for each segmentation method and display clustering scores in the title.</span>
<span class="sd">    Parameters:</span>
<span class="sd">    segmentations_dict (Dict[str, AnnData]): Dictionary of AnnData objects for each segmentation method.</span>
<span class="sd">    clustering_scores (Dict[str, Tuple[float, float]]): Dictionary of clustering scores for each method.</span>
<span class="sd">    output_path (Path): Path to the directory where the plots will be saved.</span>
<span class="sd">    palette (Dict[str, str]): Dictionary mapping segmentation method names to color codes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">method</span><span class="p">,</span> <span class="n">adata</span> <span class="ow">in</span> <span class="n">segmentations_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
        <span class="n">adata_copy</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">sc</span><span class="o">.</span><span class="n">pp</span><span class="o">.</span><span class="n">subsample</span><span class="p">(</span><span class="n">adata_copy</span><span class="p">,</span> <span class="n">n_obs</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
        <span class="n">sc</span><span class="o">.</span><span class="n">pp</span><span class="o">.</span><span class="n">normalize_total</span><span class="p">(</span><span class="n">adata_copy</span><span class="p">)</span>
        <span class="c1"># Plot UMAP colored by cell type</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
        <span class="n">sc</span><span class="o">.</span><span class="n">pp</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">adata_copy</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
        <span class="n">sc</span><span class="o">.</span><span class="n">tl</span><span class="o">.</span><span class="n">umap</span><span class="p">(</span><span class="n">adata_copy</span><span class="p">,</span> <span class="n">spread</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
        <span class="n">sc</span><span class="o">.</span><span class="n">pl</span><span class="o">.</span><span class="n">umap</span><span class="p">(</span><span class="n">adata_copy</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;celltype_major&#39;</span><span class="p">,</span> <span class="n">palette</span><span class="o">=</span><span class="n">palette</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># Add clustering scores to the title</span>
        <span class="n">ch_score</span><span class="p">,</span> <span class="n">sh_score</span> <span class="o">=</span> <span class="n">compute_clustering_scores</span><span class="p">(</span><span class="n">adata_copy</span><span class="p">,</span> <span class="n">cell_type_column</span><span class="o">=</span><span class="s1">&#39;celltype_major&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2"> - UMAP</span><span class="se">\n</span><span class="s2">Calinski-Harabasz: </span><span class="si">{</span><span class="n">ch_score</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">, Silhouette: </span><span class="si">{</span><span class="n">sh_score</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># Save the figure</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">output_path</span> <span class="o">/</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s1">_umap_with_scores.pdf&#39;</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>





<div class="viewcode-block" id="plot_entropy_boxplots">
<a class="viewcode-back" href="../../../api/validation/utils/index.html#segger.validation.utils.plot_entropy_boxplots">[docs]</a>
<span class="k">def</span> <span class="nf">plot_entropy_boxplots</span><span class="p">(</span><span class="n">entropy_boxplot_data</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">output_path</span><span class="p">:</span> <span class="n">Path</span><span class="p">,</span> <span class="n">palette</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plot boxplots for neighborhood entropy across different segmentation methods by cell type.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    entropy_boxplot_data (pd.DataFrame): DataFrame containing neighborhood entropy data for all segmentation methods.</span>
<span class="sd">    output_path (Path): Path to the directory where the plot will be saved.</span>
<span class="sd">    palette (Dict[str, str]): Dictionary mapping segmentation method names to color codes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
    <span class="n">sns</span><span class="o">.</span><span class="n">boxplot</span><span class="p">(</span>
        <span class="n">x</span><span class="o">=</span><span class="s1">&#39;Cell Type&#39;</span><span class="p">,</span> 
        <span class="n">y</span><span class="o">=</span><span class="s1">&#39;Neighborhood Entropy&#39;</span><span class="p">,</span> 
        <span class="n">hue</span><span class="o">=</span><span class="s1">&#39;Segmentation Method&#39;</span><span class="p">,</span> 
        <span class="n">data</span><span class="o">=</span><span class="n">entropy_boxplot_data</span><span class="p">,</span> 
        <span class="n">palette</span><span class="o">=</span><span class="n">palette</span>
    <span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Neighborhood Entropy&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Cell Type&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Neighborhood Entropy&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">bbox_to_anchor</span><span class="o">=</span><span class="p">(</span><span class="mf">1.05</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="s1">&#39;upper left&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">rotation</span><span class="o">=</span><span class="mi">45</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">output_path</span> <span class="o">/</span> <span class="s1">&#39;neighborhood_entropy_boxplots.pdf&#39;</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>

    
    


<div class="viewcode-block" id="plot_sensitivity_boxplots">
<a class="viewcode-back" href="../../../api/validation/utils/index.html#segger.validation.utils.plot_sensitivity_boxplots">[docs]</a>
<span class="k">def</span> <span class="nf">plot_sensitivity_boxplots</span><span class="p">(</span><span class="n">sensitivity_boxplot_data</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">output_path</span><span class="p">:</span> <span class="n">Path</span><span class="p">,</span> <span class="n">palette</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plot boxplots for sensitivity across different segmentation methods by cell type.</span>
<span class="sd">    Parameters:</span>
<span class="sd">    sensitivity_boxplot_data (pd.DataFrame): DataFrame containing sensitivity data for all segmentation methods.</span>
<span class="sd">    output_path (Path): Path to the directory where the plot will be saved.</span>
<span class="sd">    palette (Dict[str, str]): Dictionary mapping segmentation method names to color codes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
    <span class="n">sns</span><span class="o">.</span><span class="n">boxplot</span><span class="p">(</span>
        <span class="n">x</span><span class="o">=</span><span class="s1">&#39;Cell Type&#39;</span><span class="p">,</span> 
        <span class="n">y</span><span class="o">=</span><span class="s1">&#39;Sensitivity&#39;</span><span class="p">,</span> 
        <span class="n">hue</span><span class="o">=</span><span class="s1">&#39;Segmentation Method&#39;</span><span class="p">,</span> 
        <span class="n">data</span><span class="o">=</span><span class="n">sensitivity_boxplot_data</span><span class="p">,</span> 
        <span class="n">palette</span><span class="o">=</span><span class="n">palette</span>
    <span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Sensitivity Score&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Cell Type&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Sensitivity&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">bbox_to_anchor</span><span class="o">=</span><span class="p">(</span><span class="mf">1.05</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="s1">&#39;upper left&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">rotation</span><span class="o">=</span><span class="mi">45</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">output_path</span> <span class="o">/</span> <span class="s1">&#39;sensitivity_boxplots.pdf&#39;</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>

</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">Segger</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.0.2</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
    </div>

    

    
  </body>
</html>