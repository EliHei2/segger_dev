#!/usr/bin/env python3
"""
Script to compare the similarity between cell clustering labels generated by 
gene-cell clustering and the annotated cell types from the original data.

This script:
1. Loads the clustering results from run_gene_cell_clustering.py
2. Loads the annotated cell types from process_dataset.py
3. Computes various similarity metrics between the two clustering schemes
4. Creates visualizations to show the relationship between clusters and cell types
"""

import sys
from pathlib import Path
import pickle
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import scanpy as sc
from sklearn.metrics import (
    adjusted_rand_score, normalized_mutual_info_score, 
    homogeneity_score, completeness_score, v_measure_score,
    confusion_matrix, classification_report
)
from sklearn.manifold import TSNE
import umap
from typing import Dict, List, Tuple, Optional
import warnings
warnings.filterwarnings('ignore')

# Add project root to Python path
project_root = Path(__file__).parent.parent.parent
sys.path.append(str(project_root))

def load_clustering_results(edge_type='tx-bd'):
    """Load the clustering results from the gene-cell clustering analysis."""
    # Load clustering results
    clustering_file = Path('intermediate_data') / f'clustering_results_{edge_type}.pkl'
    
    if clustering_file.exists():
        with open(clustering_file, 'rb') as f:
            clustering_results = pickle.load(f)
    else:
        print("Clustering results not found. Please run run_gene_cell_clustering.py first.")
        return None
    
    return clustering_results

def load_annotated_cell_types():
    """Load the annotated cell types from the original data."""
    # Load cell types annotation
    cell_types = pd.read_csv(Path('data_xenium') / 'cell_groups.csv')
    cell_types_dict = dict(zip(cell_types['cell_id'], cell_types['group']))
    
    # Load cell types order for consistent ordering
    cell_types_order = pd.read_csv(Path('data_xenium') / 'cell_types_order_color.csv')
    cell_order = cell_types_order.sort_values('Order')['Cell Type'].tolist()
    
    # Create cell type to color mapping
    cell_type_to_color = dict(zip(cell_types_order['Cell Type'], cell_types_order['Color']))
    
    return cell_types_dict, cell_order, cell_type_to_color

def align_cell_ids(clustering_cell_ids, annotated_cell_ids):
    """Align cell IDs between clustering results and annotated data."""
    # Find common cell IDs
    common_cells = set(clustering_cell_ids) & set(annotated_cell_ids.keys())
    
    if len(common_cells) == 0:
        raise ValueError("No common cell IDs found between clustering and annotation data")
    
    print(f"Found {len(common_cells)} common cells out of {len(clustering_cell_ids)} clustered cells")
    
    # Create mapping for common cells
    clustering_to_annotated = {}
    for cell_id in common_cells:
        clustering_to_annotated[cell_id] = annotated_cell_ids[cell_id]
    
    return list(common_cells), clustering_to_annotated

def compute_similarity_metrics(cluster_labels, true_labels):
    """Compute various similarity metrics between clustering and true labels."""
    metrics = {}
    
    # Adjusted Rand Index
    metrics['adjusted_rand_score'] = adjusted_rand_score(true_labels, cluster_labels)
    
    # Normalized Mutual Information
    metrics['normalized_mutual_info_score'] = normalized_mutual_info_score(true_labels, cluster_labels)
    
    # Homogeneity, Completeness, and V-measure
    metrics['homogeneity_score'] = homogeneity_score(true_labels, cluster_labels)
    metrics['completeness_score'] = completeness_score(true_labels, cluster_labels)
    metrics['v_measure_score'] = v_measure_score(true_labels, cluster_labels)
    
    return metrics

def create_confusion_matrix(cluster_labels, true_labels, cluster_names=None, true_names=None):
    """Create and visualize confusion matrix between clustering and true labels."""
    # Create confusion matrix
    cm = confusion_matrix(true_labels, cluster_labels)
    
    # Create figure
    fig, ax = plt.subplots(figsize=(12, 10))
    
    # Plot confusion matrix
    sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', ax=ax,
                xticklabels=cluster_names, yticklabels=true_names)
    ax.set_xlabel('Predicted Clusters')
    ax.set_ylabel('True Cell Types')
    ax.set_title('Confusion Matrix: Clustering vs True Cell Types')
    # Set y-axis tick labels to true_names if provided
    if true_names is not None:
        ax.set_yticklabels(true_names, rotation=0)
    
    return fig, cm

def analyze_cluster_cell_type_distribution(cluster_labels, true_labels, 
                                         cluster_names, true_names):
    """Analyze the distribution of cell types within each cluster."""
    # Create DataFrame for analysis
    df = pd.DataFrame({
        'cluster': cluster_labels,
        'cell_type': true_labels
    })
    
    # Create cross-tabulation
    cross_tab = pd.crosstab(df['cluster'], df['cell_type'], normalize='index')
    
    # Create figure
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(20, 8))
    
    # Plot heatmap of cluster-cell type distribution
    sns.heatmap(cross_tab, annot=True, fmt='.2f', cmap='YlOrRd', ax=ax1,
                xticklabels=true_names, yticklabels=cluster_names)
    ax1.set_xlabel('True Cell Types')
    ax1.set_ylabel('Predicted Clusters')
    ax1.set_title('Cell Type Distribution within Clusters')
    # Set x-axis tick labels to true_names if provided
    if true_names is not None:
        ax1.set_xticklabels(true_names, rotation=90)
    if cluster_names is not None:
        ax1.set_yticklabels(cluster_names, rotation=0)
    
    # Plot bar chart of dominant cell types per cluster
    dominant_cell_types = cross_tab.idxmax(axis=1)
    dominant_proportions = cross_tab.max(axis=1)
    
    bars = ax2.bar(range(len(dominant_cell_types)), dominant_proportions)
    ax2.set_xlabel('Cluster')
    ax2.set_ylabel('Proportion of Dominant Cell Type')
    ax2.set_title('Dominant Cell Type Proportion per Cluster')
    ax2.set_xticks(range(len(dominant_cell_types)))
    ax2.set_xticklabels([f'Cluster {i+1}' for i in range(len(dominant_cell_types))])
    
    # Add value labels on bars
    for i, (bar, prop) in enumerate(zip(bars, dominant_proportions)):
        ax2.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.01,
                f'{prop:.2f}', ha='center', va='bottom')
    
    plt.tight_layout()
    
    return fig, cross_tab, dominant_cell_types, dominant_proportions

def create_umap_visualization(coordinates, cluster_labels, true_labels, 
                            cell_ids, cluster_names, true_names):
    """Create UMAP visualization showing both clustering and true labels using precomputed coordinates."""
    # coordinates: numpy array of shape (n_cells, 3)
    # Create figure with two 3D subplots
    fig = plt.figure(figsize=(16, 6))
    ax1 = fig.add_subplot(1, 2, 1)
    ax2 = fig.add_subplot(1, 2, 2)
    
    # Plot clustering results
    scatter1 = ax1.scatter(coordinates[:, 0], coordinates[:, 1], c=cluster_labels, 
                          cmap='tab10', alpha=0.5, s=20)
    ax1.set_xlabel('UMAP 1')
    ax1.set_ylabel('UMAP 2')
    ax1.set_title('Cell Clustering Results')
    
    # Add legend for clusters
    legend1 = ax1.legend(*scatter1.legend_elements(), title="Clusters")
    ax1.add_artist(legend1)
    
    # Plot true cell types
    scatter2 = ax2.scatter(coordinates[:, 0], coordinates[:, 1], c=true_labels, 
                          cmap='tab20', alpha=0.5, s=20)
    ax2.set_xlabel('UMAP 1')
    ax2.set_ylabel('UMAP 2')
    ax2.set_title('True Cell Types')
    
    # Add legend for cell types with true_names if provided
    import matplotlib.patches as mpatches
    if true_names is not None:
        # Map numeric labels to names
        handles = []
        unique_labels = np.unique(true_labels)
        for idx in unique_labels:
            if idx < len(true_names):
                handles.append(mpatches.Patch(color=plt.cm.tab20(idx / max(unique_labels)), label=true_names[idx]))
            else:
                handles.append(mpatches.Patch(color=plt.cm.tab20(idx / max(unique_labels)), label=str(idx)))
        ax2.legend(handles=handles, title="Cell Types", bbox_to_anchor=(1.05, 1), loc='upper left')
    else:
        legend2 = ax2.legend(*scatter2.legend_elements(), title="Cell Types")
        ax2.add_artist(legend2)
    
    plt.tight_layout()
    
    return fig

def create_detailed_cluster_analysis(cluster_labels, true_labels, cell_ids, 
                                   cluster_names, true_names):
    """Create detailed analysis of each cluster."""
    # Create DataFrame
    df = pd.DataFrame({
        'cell_id': cell_ids,
        'cluster': cluster_labels,
        'cell_type': true_labels
    })
    
    # Analyze each cluster
    cluster_analysis = {}
    for cluster_id in np.unique(cluster_labels):
        cluster_mask = cluster_labels == cluster_id
        cluster_cells = df[cluster_mask]
        
        # Count cell types in this cluster
        cell_type_counts = cluster_cells['cell_type'].value_counts()
        total_cells = len(cluster_cells)
        
        # Calculate purity (proportion of most common cell type)
        purity = cell_type_counts.iloc[0] / total_cells if total_cells > 0 else 0
        
        cluster_analysis[cluster_id] = {
            'total_cells': total_cells,
            'cell_type_distribution': cell_type_counts.to_dict(),
            'purity': purity,
            'dominant_cell_type': cell_type_counts.index[0] if len(cell_type_counts) > 0 else None,
            'cell_ids': cluster_cells['cell_id'].tolist()
        }
    
    return cluster_analysis

def save_results(metrics, cluster_analysis, output_dir):
    """Save analysis results to files."""
    output_dir = Path(output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)
    
    # Save metrics
    metrics_df = pd.DataFrame([metrics])
    metrics_df.to_csv(output_dir / 'similarity_metrics.csv', index=False)
    
    # Save cluster analysis
    cluster_analysis_df = pd.DataFrame([
        {
            'cluster_id': cluster_id,
            'total_cells': analysis['total_cells'],
            'purity': analysis['purity'],
            'dominant_cell_type': analysis['dominant_cell_type'],
            'cell_type_distribution': str(analysis['cell_type_distribution'])
        }
        for cluster_id, analysis in cluster_analysis.items()
    ])
    cluster_analysis_df.to_csv(output_dir / 'cluster_analysis.csv', index=False)
    
    print(f"Results saved to {output_dir}")

def main():
    """Main function to run the cell clustering comparison analysis."""
    print("Loading clustering results and annotated cell types...")
    
    try:
        # Load clustering results
        results = load_clustering_results(edge_type='tx-bd')
        clustering_results = results['results']
        cell_ids = results['cell_ids']
        if clustering_results is None:
            return
        
        # Load annotated cell types
        cell_types_dict, _, _ = load_annotated_cell_types()
        
        # Modify the cell_types_dict values as requested
        for k, v in cell_types_dict.items():
            if v in ["Endocrine 1", "Endocrine 2"]:
                cell_types_dict[k] = "Endocrine"
            elif v in ["Tumor Cells", "CFTR- Tumor Cells"]:
                cell_types_dict[k] = "Tumor Cells"
        
        # Get the first clustering result (you can modify this to use specific parameters)
        first_key = list(clustering_results.keys())[0]
        cell_clustering = clustering_results[first_key]['cell_clustering']
        
        # Extract cell clustering labels and cell IDs
        cluster_labels = cell_clustering['cluster_labels']
        umap_coords = cell_clustering['coordinates']
        
        print(f"Loaded clustering results for {len(cell_ids)} cells")
        print(f"Number of clusters: {len(np.unique(cluster_labels))}")
        
        # Align cell IDs
        common_cells, clustering_to_annotated = align_cell_ids(cell_ids, cell_types_dict)
        
        # Filter data to common cells
        common_indices = [cell_ids.index(cell) for cell in common_cells]
        filtered_cluster_labels = cluster_labels[common_indices] - 1
        filtered_true_labels = [clustering_to_annotated[cell] for cell in common_cells]
        filtered_umap_coords = umap_coords[common_indices]
        
        # Convert labels to numeric for analysis
        # Reorder unique_true_labels according to desired_true_names_order
        unique_true_labels = list(set(filtered_true_labels))
        ordered_true_labels = [label for label in ["Acinar", "Ductal", "Endocrine", "Fibroblasts", "Smooth Muscle Cells", "Endothelial", 
                                                 "Lymphatic Endothelial Cells", "Macrophages", "T Cells", "B Cells", "Mast Cells", 
                                                 "CXCL9/10 Cells", "Tumor Cells", "Metaplastic Cells"] if label in unique_true_labels]
        true_label_to_idx = {label: idx for idx, label in enumerate(ordered_true_labels)}
        numeric_true_labels = [true_label_to_idx[label] for label in filtered_true_labels]
        
        # Create label names for visualization
        cluster_names = [f'Cluster {i+1}' for i in range(len(np.unique(filtered_cluster_labels)))]
        true_names = ordered_true_labels
        
        print(f"Analyzing {len(common_cells)} common cells...")
        
        # Compute similarity metrics
        print("Computing similarity metrics...")
        metrics = compute_similarity_metrics(filtered_cluster_labels, numeric_true_labels)
        
        # Print metrics
        print("\nSimilarity Metrics:")
        for metric_name, value in metrics.items():
            print(f"  {metric_name}: {value:.4f}")
        
        # Create visualizations
        print("Creating visualizations...")
        output_dir = Path('figures') / 'tx-bd' / 'clustering_comparison'
        output_dir.mkdir(parents=True, exist_ok=True)
        
        # Confusion matrix
        fig_cm, cm = create_confusion_matrix(filtered_cluster_labels, numeric_true_labels,
                                           cluster_names, true_names)
        fig_cm.savefig(output_dir / 'confusion_matrix.png', dpi=300, bbox_inches='tight')
        plt.close(fig_cm)
        
        # Cluster-cell type distribution
        fig_dist, cross_tab, dominant_cell_types, dominant_proportions = analyze_cluster_cell_type_distribution(
            filtered_cluster_labels, numeric_true_labels, cluster_names, true_names
        )
        fig_dist.savefig(output_dir / 'cluster_cell_type_distribution.png', dpi=300, bbox_inches='tight')
        plt.close(fig_dist)
        
        # UMAP visualization (now using precomputed coordinates)
        fig_umap = create_umap_visualization(filtered_umap_coords, filtered_cluster_labels, 
                                           numeric_true_labels, common_cells, cluster_names, true_names)
        fig_umap.savefig(output_dir / 'umap_comparison.png', dpi=300, bbox_inches='tight')
        plt.close(fig_umap)
        
        # Detailed cluster analysis
        cluster_analysis = create_detailed_cluster_analysis(
            filtered_cluster_labels, numeric_true_labels, common_cells, cluster_names, true_names
        )
        
        # Save results
        save_results(metrics, cluster_analysis, output_dir)
        
        # Print summary
        print(f"\nAnalysis completed!")
        print(f"Results saved to: {output_dir}")
        print(f"\nCluster Analysis Summary:")
        for cluster_id, analysis in cluster_analysis.items():
            print(f"  Cluster {cluster_id + 1}: {analysis['total_cells']} cells, "
                  f"purity: {analysis['purity']:.3f}, "
                  f"dominant: {true_names[analysis['dominant_cell_type']]}")
        
    except Exception as e:
        print(f"Error during analysis: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    main() 